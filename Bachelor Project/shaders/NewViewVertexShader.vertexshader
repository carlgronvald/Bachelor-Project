#version 330 core

#define VIEWNUM 5

layout(location=0) in vec3 vertexPosition_modelspace;
layout(location=1) in vec3 color;
layout(location=2) in vec3 normal;

out vec3 vColor;
out vec2 vertexxy;
out vec3 vertexnormal;
out float vertexz;
out float vertexw;
out float angles[VIEWNUM];
out float distances[VIEWNUM];
out float viewDistances[VIEWNUM];

uniform mat4 MVP;
uniform mat4 viewMVP[VIEWNUM];
uniform vec3 viewDir[VIEWNUM];
uniform vec3 viewLoc[VIEWNUM];
uniform vec3 camLoc;
uniform vec3 camDir;

uniform sampler2D depthTexture[VIEWNUM];
uniform float minDepth[VIEWNUM];
uniform float maxDepth[VIEWNUM];
uniform sampler2D confidenceTexture[VIEWNUM];
uniform sampler2D colmapDepth[VIEWNUM];

//Proportionality constants for gaussian weights
uniform float kdt;
uniform float kd;
uniform float kt;
uniform float kc;
uniform float kdist;

float weight(float d2, float x, float c) { //Returns the weighing of a view given squared distance, angle, and shadow map confidence
	return exp((-d2*x*x*kdt - d2*kd - x*x*kt - c*c*kc));
}

float cameraDepth(vec4 tex, int i) {
	return dot(tex, vec4(1,256,65536,16777216))/16777216.0 * (maxDepth[i]-minDepth[i]) + minDepth[i];
}

float camera(vec4 tex, int i) {
	return dot(tex, vec4(1,256,65536,16777216))/16777216.0 * (maxDepth[i]-minDepth[i]) + minDepth[i];
}

float near = 0.1; 
float far  = 100.0; 
  
float LinearizeDepth(float depth) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));	
}

void main() {
	gl_Position = MVP * vec4(vertexPosition_modelspace, 1);
	vertexnormal = normal;

	//viewParts = vec2( viewDir[0], viewDir2[0] );

	vec2 pos = (gl_Position.xy/gl_Position.w); //This is the screen position in the [-1,1] square.
	vec4 viewPos;
	for(int i=0;i<VIEWNUM;i++) {
		angles[i] = acos(dot(viewDir[i], camDir));
		viewPos = viewMVP[i] * vec4(vertexPosition_modelspace,1);

		distances[i] = abs(LinearizeDepth( texture(depthTexture[i], (viewPos.xy/viewPos.w+vec2(1))/2).x ) - viewPos.w*1.1); 
	}
	vertexxy = (pos+vec2(1))/2;
	vertexz = gl_Position.z;
	vertexw = gl_Position.w;

	vColor = color;
	//gl_Position = viewPos;
}



/*for(int i=0;i<5;i++) {
	
}*/

/*
		maxXdpos = vec4(vertexPosition_modelspace+xDir.xyz,1);
		maxYdpos = vec4(vertexPosition_modelspace+yDir.xyz,1);
		
		dxview = viewMVP[i] * maxXdpos;
		dyview = viewMVP[i] * maxYdpos;
		gl_Position = MVP * maxYdpos;
		viewPos = viewMVP[i] * vec4(vertexPosition_modelspace,1);
		dUVx = (dxview.xy/dxview.w)-viewPos.xy/viewPos.w;
		dUVy = (dyview.xy/dyview.w)-viewPos.xy/viewPos.w;

		float d2 = dot(viewLoc[i]-camLoc,viewLoc[i]-camLoc);
		float x = acos(dot(viewDir[i],camDir));

		
		d = abs(cameraDepth( texture(depthTexture[0], (viewPos.xy/viewPos.z+vec2(1))/2), 0 ) - viewPos.z);

		viewParts[i] = clamp(weight(d2,x)  - pow(  viewPos.x/viewPos.z*viewPos.x/viewPos.z, 64) - pow(viewPos.y/viewPos.z*viewPos.y/viewPos.z, 64)  - pow(d*3,4) ,0,1);
		totalViewPart += viewParts[i];
		UVs[i] = ((viewPos.xy/viewPos.w)+vec2(1,1))/2;
		dUV[i] = mat2(dUVx,dUVy);
		*/